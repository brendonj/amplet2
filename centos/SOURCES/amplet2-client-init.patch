--- a/amplet2-client.init	1970-01-01 00:00:00.000000000 +0000
+++ b/amplet2-client.init	2014-06-25 03:43:56.000000000 +0000
@@ -0,0 +1,246 @@
+#!/bin/sh
+### BEGIN INIT INFO
+# Provides:          amplet2
+# Required-Start:    $remote_fs $network $local_fs
+# Required-Stop:     $remote_fs $network $local_fs
+# Default-Start:     2 3 4 5
+# Default-Stop:      0 1 6
+# Short-Description: AMP measurement daemon
+# Description:       AMP measurement daemon
+### END INIT INFO
+
+# Author: Brendon Jones <brendonj@waikato.ac.nz>
+
+# PATH should only include /usr/* if it runs after the mountnfs.sh script
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+DESC=amplet2		         # Introduce a short description here
+PKG_NAME=amplet2-client
+DAEMON_NAME=amplet2             # Introduce the short server's name here
+DAEMON=/usr/sbin/$DAEMON_NAME   # Introduce the server's location here
+SCRIPTNAME=/etc/init.d/$PKG_NAME
+START_DAEMON=1
+DAEMON_OPTS="-d"
+CONFDIR=/etc/amplet2/clients
+PIDDIR=/var/run/amplet2
+
+# Exit if the package is not installed
+[ -x $DAEMON ] || exit 0
+
+# Read configuration variable file if it is present
+[ -r /etc/default/$PKG_NAME ] && . /etc/default/$PKG_NAME
+
+# Don't start the daemon unless it has been manually enabled in
+# /etc/default/amplet2-client. There is too much configuration required
+# to assume it can be started initially.
+[ $START_DAEMON -gt 0 ] || exit 0
+
+# source function library
+. /etc/rc.d/init.d/functions
+
+#
+# Simple function to check if an item is contained within a space seperated list
+#
+contains()
+{
+    for item in $1; do
+        if [ $item = $2 ]; then
+            return 0
+        fi
+    done
+    return 1
+}
+
+#
+# Function that starts the daemon/service
+#
+do_start()
+{
+    # Make sure that the pid dir exists
+    if [ ! -d $PIDDIR ]; then
+        mkdir -p $PIDDIR
+        #chown
+        #chgrp
+    fi
+
+    # For every config file, try to run an amplet client
+    for client in ${CONFDIR}/*.conf; do
+        NAME=${client#$CONFDIR/}
+        NAME=${NAME%.conf}
+        PIDFILE=${PIDDIR}/${NAME%.conf}.pid
+
+        # Start the client if no client is specified, or if it matches
+        if ([ $# -eq 0 ] || contains $@ $NAME); then
+            # TODO return appropriate thing if already running
+            # use start-stop-daemon --test?
+	    echo -n $NAME
+            daemon --user=measure --pidfile=$PIDFILE \
+		    $DAEMON $DAEMON_OPTS -c $client -p $PIDFILE
+
+            case "$?" in
+                0) SUCCESS=$((SUCCESS+1)); \
+                        [ "$VERBOSE" != no ] && echo_success $NAME ;;
+                *) FAILED=$((FAILED+1)); \
+                        [ "$VERBOSE" != no ] && echo_failure $NAME ;;
+            esac
+	    echo
+        fi
+    done
+
+    # No failures and at least one success, return success
+    if [[ $FAILED -eq 0 && $SUCCESS -gt 0 ]]; then
+        return 0
+    fi
+
+    # Some failures and some successes, return warning
+    if [[ $FAILED -gt 0 && $SUCCESS -gt 0 ]]; then
+        return 1
+    fi
+
+    # No successes, return failed
+    return 2
+}
+
+#
+# Function that stops the daemon/service
+#
+do_stop()
+{
+    SUCCESS=0
+    FAILED=0
+
+    for pidfile in ${PIDDIR}/*.pid; do
+	if [ ! -f $pidfile ]; then
+	    continue
+	fi
+        NAME=${pidfile#$PIDDIR/}
+        NAME=${NAME%.pid}
+
+        # Stop the client if no client is specified, or if it matches
+        if ([ $# -eq 0 ] || contains $@ $NAME); then
+	    echo -n $NAME
+	    killproc -p $pidfile $DAEMON
+
+            case "$?" in
+                0|7) SUCCESS=$((SUCCESS+1)); \
+                    [ "$VERBOSE" != no ] && echo_success $NAME ;;
+                *) FAILED=$((FAILED+1)); \
+                    [ "$VERBOSE" != no ] && echo_failure $NAME ;;
+            esac
+	    echo
+        fi
+    done
+
+    # No failures and no successes - client(s) not running
+    if [[ $FAILED -eq 0 && $SUCCESS -eq 0 ]]; then
+	echo "Not running"
+        return 0
+    fi
+
+    # No failures and at least one success, return success
+    if [[ $FAILED -eq 0 && $SUCCESS -gt 0 ]]; then
+        return 0
+    fi
+
+    # Some failures and some successes, return warning
+    if [[ $FAILED -gt 0 && $SUCCESS -gt 0 ]]; then
+        return 1
+    fi
+
+    # No successes, return failed
+    return 2
+}
+
+#
+# Function that checks the status of any amplet2 clients
+#
+do_status() {
+    RETVAL=0
+    for client in ${CONFDIR}/*.conf; do
+        NAME=${client#$CONFDIR/}
+        NAME=${NAME%.conf}
+        PIDFILE=${PIDDIR}/${NAME%.conf}.pid
+
+        # Query the client if no client is specified, or if it matches
+        if ([ $# -eq 0 ] || contains $@ $NAME); then
+            status -p $PIDFILE "$NAME"
+            if [ $? -gt 0 ]; then
+                RETVAL=2
+            fi
+        fi
+    done
+    return $RETVAL
+}
+
+#
+# Function that sends a SIGHUP to the daemon/service
+#
+do_reload() {
+    #
+    # If the daemon can reload its configuration without
+    # restarting (for example, when it is sent a SIGHUP),
+    # then implement that here.
+    #
+    for client in ${CONFDIR}/*.conf; do
+        NAME=${client#$CONFDIR/}
+        NAME=${NAME%.conf}
+        PIDFILE=${PIDDIR}/${NAME%.conf}.pid
+
+        # Reload the client if no client is specified, or if it matches
+        if ([ $# -eq 0 ] || contains $@ $NAME); then
+	    echo -n $NAME
+	    killproc -p $PIDFILE $DAEMON -HUP
+	    echo
+        fi
+    done
+    return 0
+}
+
+case "$1" in
+  start)
+    [ "$VERBOSE" != no ] && echo "Starting $DESC clients:"
+    shift
+    do_start $@
+  ;;
+  stop)
+        [ "$VERBOSE" != no ] && echo "Stopping $DESC:"
+	 shift
+        do_stop $@
+        ;;
+  status)
+	shift
+	echo "Current status of $DESC clients:"
+	do_status $@ && exit 0 || exit $?
+       ;;
+  reload)
+        #
+        # If do_reload() is not implemented then leave this commented out
+	# and leave 'force-reload' as an alias for 'restart'.
+        #
+        [ "$VERBOSE" != no ] && echo "Reloading $DESC clients:"
+	shift
+        do_reload $@
+        ;;
+  restart)
+        #
+        # If the "reload" option is implemented then remove the
+        # 'force-reload' alias
+        #
+	shift
+        echo "Stopping $DESC clients:"
+        do_stop $@
+        case "$?" in
+          0|1)
+        	echo "Starting $DESC clients:"
+                do_start $@
+		;;
+          *)
+                # Failed to stop
+                ;;
+        esac
+        ;;
+  *)
+        echo "Usage: $SCRIPTNAME {start|stop|status|restart|reload}" >&2
+        #echo "Usage: $SCRIPTNAME {start|stop|status|restart|force-reload}" >&2
+        exit 3
+        ;;
+esac
