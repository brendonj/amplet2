% Simple Shovel config to move AMP data from the local broker on an amplet
% machine back to the broker on the central server.
%
% For information on configuring Shovel see http://www.rabbitmq.com/shovel.html

[
{rabbit, [
    % restrict the local broker to only listen on localhost
    {tcp_listeners, [{'127.0.0.1', 5672}]}
]},

{rabbitmq_shovel,
    [{shovels,
	[{test_shovel,

	    [{sources,

		% In our case with amplets it seems likely that the source is
		% always going to be the local broker and only the local broker
		[{broker,"amqp://"},

		% Declarations set things up when we first connect to the
		% broker. Exchanges and queues will be created if they don't
		% already exist, if they do already exist then our declarations
		% here must match exactly the way the existing item was
		% originally defined or it is an error.
		{declarations,
		    [

		    % This is the exchange that AMP data is sent to locally.
		    % I think this has to be declared explicitly because it
		    % needs to be set durable and we need to know the name to
		    % send data to it.
		    {
			'exchange.declare',
			[
			    {exchange, <<"amp_exchange">>},
			    {type, <<"direct">>},
			    durable
			]
		    },

		    % This is the queue that local data will be routed to by
		    % the amp_exchange. This could probably be anonymous, I
		    % don't think we care about the name? Does the queue need
		    % to be set durable?
		    {
			'queue.declare',
			[
			    {queue, <<"foo1">>},
			    durable
			]
		    },

		    % Bind any traffic headed to the amp_exchange and using the
		    % routing key "test" to go to the queue declared above.
		    {
			'queue.bind',
			[
			    {exchange, <<"amp_exchange">>},
			    {queue, <<"foo1">>},
			    {routing_key, <<"test">>}
			]
		    }
		    ]
		}
		]},

	    {destinations,

		% The destination is where the data should be shipped to.
                % For now we are using prophet as the server (it is running
                % nntsc etc). From the documentation it appears that all
                % servers listed here are used in a round robin fashion,
                % trying the next one should the currently connected one go
                % away.
                %
                % The SSL configuration requires:
                % The cacertfile option specifies the certificates of the root
                % Certificate Authorities that we wish to implicitly trust.
                % The certfile is the client's own certificate in PEM format
                % The keyfile is the client's private key file in PEM format.
                %
                % The auth_mechanism is set to "external" with the expectation
                % that the upstream broker will be performing authentication
                % using the rabbitmq_auth_mechanism_ssl plugin - the username
                % is the Common Name from the certificate.
                [{broker, "amqps://prophet.cms.waikato.ac.nz:5671?cacertfile=/etc/rabbitmq/keys/cacert.pem&certfile=/etc/rabbitmq/keys/cert.pem&keyfile=/etc/rabbitmq/keys/key.pem&verify=verify_peer&fail_if_no_peer_cert=true&auth_mechanism=external"},

		% TODO:
		% Should the client shovels be declaring things on the main
		% server (new queues or something for the host/test combination?
		% Or should these be created once by our server configuration
		% and left alone by the shovel?
		{declarations,
		[

		% Make sure the target exchange exists on the server
		{
		    'exchange.declare',
		    [
			{exchange, <<"amp_exchange">>},
			{type, <<"direct">>},
			durable
		    ]
		},

		% Make sure the target queue exists on the server. This
		% probably can be anonymous because don't care about the name?
		{
		    'queue.declare',
		    [
			{queue, <<"foo1">>},
			durable
		    ]
		},

		% Bind the queue to the exchange using the routing key as per
		% on the source config.
		{
		    'queue.bind',
		    [
			{exchange, <<"amp_exchange">>},
			{queue, <<"foo1">>},
			{routing_key, <<"test">>}
		    ]
		}
		]
		}
		]},

	    % This is the queue that messages should be shoveled from. This
	    % queue must exist, but we can use anonymous queues with the empty
	    % binary string <<>>
	    {queue, <<"foo1">>},

	    % Make sure that acknowledgements are sent after message is
	    % confirmed to have arrived at the destination broker. This gives
	    % us our local cache on amplets that used to be performed by xfer.
	    {ack_mode, on_confirm},

	    % Make sure that republished messages are set to be persistent to
	    % take advantage of the durable nature of our exchanges/queues so
	    % our messages will use the local cache. If we don't set anything
	    % here they keep the values they were originally published with.
            {publish_properties, [
                {delivery_mode, 2}
                %{user_id, <<"hostname/username/ampname">>}
            ]},

	    % Set the fields that republished messages should use to make sure
	    % they hit the right exchange with the right routing key. By
	    % default the original values that the message was published with
	    % are preserved.
	    {publish_fields, [
		{exchange, <<"amp_exchange">>},
		{routing_key, <<"test">>}
		]},

	    % Delay before reconnecting if the connection to a broker goes
	    % away. Ideally this would be some sort of exponential/random
	    % backoff but it seems to be a fixed delay?
	    {reconnect_delay, 6}
	    ]}
	 ]
       }]
    }
].
