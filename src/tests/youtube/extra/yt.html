<!DOCTYPE html>
<html>
  <body>
    <!-- 1. The <iframe> (and video player) will replace this <div> tag. -->
    <div id="player"></div>

    <script>
      var video_id;
      var quality;
      var debug;

      var urlParams = new URLSearchParams(window.location.search);

      if ( urlParams.has("video") ) {
          video_id = urlParams.get("video");
      } else {
          video_id = "C0DPdy98e4c"; /* short 17s test */
      }

      if ( urlParams.has("quality") ) {
          quality = urlParams.get("quality");
      } else {
          quality = "default";
      }

      if ( urlParams.has("debug") ) {
          debug = urlParams.get("debug");
      } else {
          debug = false;
      }

      /*
       * https://developers.google.com/youtube/player_parameters
       * https://developers.google.com/youtube/iframe_api_reference
       */
      var starttime;

      if ( debug ) {
          /* TODO do something sensible if the browser can't? */
          /* can this browser actually play videos? */
          console.log("video: " +
                  !!document.createElement("video").canPlayType);
      }

      /* 2. This code loads the IFrame Player API code asynchronously. */
      var tag = document.createElement('script');

      tag.src = "https://www.youtube.com/iframe_api";
      var firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

      /*
       * 3. This function creates an <iframe> (and YouTube player)
       *  after the API code downloads.
       */
      var player;
      var timeline = []

      function getQualityHeight(quality) {
          var heights = {
              "default": 1080,
              "small": 240,
              "medium": 360,
              "large": 480,
              "hd720": 720,
              "hd1080": 1080,
              "hd1440": 1440,
              "hd2160": 2160,
              "highres": 2160,
          };

          if ( quality in heights ) {
              return heights[quality];
          }

          return heights["default"];
      }

      function getQualityWidth(quality) {
          var widths = {
              "default": 1080,
              //"small": 320,
              "small": 427,
              "medium": 640,
              "large": 583,
              "hd720": 1280,
              "hd1080": 1920,
              "hd1440": 2560,
              "hd2160": 3840,
              "highres": 3840,
          };

          if ( quality in widths ) {
              return widths[quality];
          }

          return widths["default"];
      }

      function onYouTubeIframeAPIReady() {
          if ( debug ) {
              console.log("onYouTubeIframeAPIReady");
          }
          player = new YT.Player('player', {
          height: getQualityHeight(quality),
          width: getQualityWidth(quality),
          videoId: video_id,
          playerVars: {
            'autoplay': 0,
            'controls': 0,
            'enablejsapi': 1,
            'iv_load_policy': 3,
            'rel': 0,
          },
          events: {
            'onReady': onPlayerReady,
            'onStateChange': onPlayerStateChange,
            'onPlaybackQualityChange': onQualityChange,
            'onError': onPlayerError,
          }
        });
      }

      /* 4. The API will call this function when the video player is ready. */
      function onPlayerReady(event) {
          starttime = Date.now();
          if ( debug ) {
              console.log("onPlayerReady");
          }
          /* XXX no guarantee, look for onPlaybackQualityChange event? */
          event.target.setPlaybackQuality(quality);
          event.target.playVideo();
          timeline.push({
                  "timestamp": 0,
                  "event": "ready",
                  });
      }

      function onPlayerError(event) {
          console.log("onPlayerError");
          console.log(event);
      }

      /*
       * 5. The API calls this function when the player's state changes.
       *  The function indicates that when playing a video (state=1),
       *  the player should play for six seconds and then stop.
       */
      var playtime = 0;
      var pretime = 0;
      var firstbuffer = 0;
      var buftime = 0;
      var bufcount = 0;
      var time = 0;
      var state = -1;

      function onQualityChange(event) {
          var now = Date.now();
          if ( debug ) {
              console.log("quality change: " + event.data);
          }
          timeline.push({
                  "timestamp": now - starttime,
                  "event": "quality",
                  "quality": event.data
                  });
      }

      function onPlayerStateChange(event) {
          var now = Date.now();
          if ( debug ) {
              console.log("state change at " + now);

              if ( time > 0 ) {
                  console.log("time since last event:" + (now - time));
              }

              console.log("quality options: " +
                      event.target.getPlaybackQuality() + " (" +
                      event.target.getAvailableQualityLevels() + ")");
          }

          /*
           * If this isn't the first time through we might need to update
           * some timers. Currently tracking time spent buffering and time
           * spent playing.
           */
          if ( time > 0 ) {
              /* buffering before the video starts counts separately */
              if ( state == YT.PlayerState.BUFFERING && firstbuffer > 0 ) {
                  buftime += (now - time);
                  bufcount++;
              } else if ( state == YT.PlayerState.PLAYING ) {
                  playtime += (now - time);
              }
          }

          switch ( event.data ) {
            case YT.PlayerState.UNSTARTED:
                if ( debug ) {
                    console.log("unstarted");
                    console.log((now - time) + " from previous to this point");
                }
                state = YT.PlayerState.UNSTARTED;
                timeline.push({
                        "timestamp": now - starttime,
                        "event": "unstarted",
                        });
                break;

            case YT.PlayerState.BUFFERING:
                if ( debug ) {
                    console.log("buffering");
                    console.log((now - time) + " from previous to this point");
                }
                state = YT.PlayerState.BUFFERING;
                /* pre time ends once we start to buffer for the first time */
                if ( pretime == 0 ) {
                    pretime = now - starttime;
                }
                timeline.push({
                        "timestamp": now - starttime,
                        "event": "buffering",
                        });
                break;

            case YT.PlayerState.PLAYING:
                if ( debug ) {
                    console.log("playing");
                    console.log((now - time) + " from previous to this point");
                }
                /* initial buffering ends the first time we enter play state */
                if ( firstbuffer == 0 ) {
                    if ( time == 0 ) {
                        firstbuffer = 0;
                    } else {
                        firstbuffer = (now - time);
                    }
                }
                state = YT.PlayerState.PLAYING;
                timeline.push({
                        "timestamp": now - starttime,
                        "event": "playing",
                        });
                break;

            case YT.PlayerState.ENDED:
                timeline.push({
                        "timestamp": now - starttime,
                        "event": "ended",
                        });
                youtuberesults = {
                    "video": video_id,
                    /* TODO getVideoData() is undocumented, not official */
                    "title": player.getVideoData().title,
                    "quality": event.target.getPlaybackQuality(),
                    "initial_buffering": firstbuffer,
                    "playing_time": playtime,
                    "stall_time": buftime,
                    "stall_count": bufcount,
                    "total_time": now - starttime,
                    "pre_time": pretime,
                    "reported_duration": event.target.getDuration(),
                    "timeline": timeline,
                };
                foo = youtuberesults; // XXX
                console.log(youtuberesults);

                alert("done");
                break;

            default:
                if ( debug ) {
                    console.log("new state: " + event.data);
                }
                state = event.data;
                return; /* so the time doesn't get updated */
        };
        time = now;
      }
    </script>
  </body>
</html>
